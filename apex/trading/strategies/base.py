"""
Base Strategy Class for Apex Trading System
All trading strategies must inherit from this class.
"""

from abc import ABC, abstractmethod
from typing import Dict, List, Optional, Tuple
from dataclasses import dataclass
from enum import Enum
import pandas as pd
from datetime import datetime


class SignalType(Enum):
    BUY = "buy"
    SELL = "sell"
    HOLD = "hold"


@dataclass
class Signal:
    """Trading signal generated by a strategy"""
    type: SignalType
    symbol: str
    timestamp: datetime
    price: float
    confidence: float  # 0.0 to 1.0
    metadata: Dict = None
    
    def __post_init__(self):
        if self.metadata is None:
            self.metadata = {}


@dataclass
class Position:
    """Current trading position"""
    symbol: str
    side: str  # 'long' or 'short'
    entry_price: float
    quantity: float
    timestamp: datetime
    stop_loss: Optional[float] = None
    take_profit: Optional[float] = None


class BaseStrategy(ABC):
    """
    Abstract base class for all trading strategies.
    
    To create a new strategy:
    1. Inherit from BaseStrategy
    2. Implement generate_signals()
    3. Implement calculate_indicators()
    """
    
    def __init__(self, config: Dict):
        self.name = self.__class__.__name__
        self.config = config
        self.enabled = config.get('enabled', True)
        self.timeframe = config.get('timeframe', '1h')
        self.symbols = config.get('symbols', ['BTC/USDT'])
        self.positions: List[Position] = []
        self.signals: List[Signal] = []
        
    @abstractmethod
    def calculate_indicators(self, data: pd.DataFrame) -> pd.DataFrame:
        """
        Calculate technical indicators for the strategy.
        
        Args:
            data: DataFrame with OHLCV data
            
        Returns:
            DataFrame with added indicator columns
        """
        pass
    
    @abstractmethod
    def generate_signals(self, data: pd.DataFrame) -> List[Signal]:
        """
        Generate trading signals based on indicators.
        
        Args:
            data: DataFrame with OHLCV and indicator data
            
        Returns:
            List of Signal objects
        """
        pass
    
    def validate_data(self, data: pd.DataFrame) -> bool:
        """
        Validate that data has required columns.
        
        Args:
            data: DataFrame to validate
            
        Returns:
            True if valid, False otherwise
        """
        required_columns = ['open', 'high', 'low', 'close', 'volume']
        return all(col in data.columns for col in required_columns)
    
    def get_position(self, symbol: str) -> Optional[Position]:
        """Get current position for a symbol"""
        for pos in self.positions:
            if pos.symbol == symbol:
                return pos
        return None
    
    def add_position(self, position: Position):
        """Add a new position"""
        self.positions.append(position)
    
    def close_position(self, symbol: str) -> bool:
        """Close position for a symbol"""
        for i, pos in enumerate(self.positions):
            if pos.symbol == symbol:
                self.positions.pop(i)
                return True
        return False
    
    def get_performance_metrics(self) -> Dict:
        """
        Calculate strategy performance metrics.
        
        Returns:
            Dictionary with performance metrics
        """
        return {
            'strategy': self.name,
            'total_signals': len(self.signals),
            'buy_signals': len([s for s in self.signals if s.type == SignalType.BUY]),
            'sell_signals': len([s for s in self.signals if s.type == SignalType.SELL]),
            'active_positions': len(self.positions),
            'enabled': self.enabled
        }
    
    def __str__(self):
        return f"{self.name}(timeframe={self.timeframe}, enabled={self.enabled})"
